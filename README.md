# qt-traffic-light
## Use Model RealTime with a Qt application
### System toolchain requirement
To test this scenario the following setup is done.
1.	Qt 6.7 is installed on Windows machine with MinGW toolchain.
2.	[Model RealTime](https://model-realtime.hcldoc.com/help/index.jsp) installed on Eclipse.

### Software reference
A sample Qt application has been developed based on the following open-source Model RealTime sample:

https://github.com/HCL-TECH-SOFTWARE/traffic-light-web 

This sample uses a web page as its UI, and in the Qt application it has been replaced with a Qt UI based on the following sample from the Qt documentation:

https://doc.qt.io/qt-6/qtstatemachine-trafficlight-example.html

The state machine logic of this Qt sample was removed and replaced with the state machine of the Model RealTime sample.

### How the Qt application works
We choose to let the main thread run the Qt UI. In main.cpp the QApplication is created with a main window. The main thread will then simply run the application’s event loop which handles all Qt UI events.

In the main window constructor (MainWindow.cpp) we create a QThread (MyThread.cpp) responsible for running the realtime part of the application. We use signals and slots as the means of communicating messages from the realtime part to the Qt UI.

When the QThread starts to run (function MyThread::run()) it will call RTMain::entryPoint() and then pass necessary arguments which otherwise is provided by the TargetRTS. In the sample these are the path to the Qt application and “-URTS_DEBUG=quit” (to not use the model debugger). If you launch the Qt application with command-line arguments, these are passed to the TargetRTS. For example, to launch so that you can attach the model debugger to the application, use the `obslisten=<port>` argument.

The realtime part of the application is run by MyThread and uses a top capsule TLSystem with these capsule parts:
#### trafficLight
Implements the traffic light logic using an Model RealTime state machine. This part is independent of Qt.
#### qtUI
Responsible for communication from the realtime part of the application to the Qt UI. When the red, green and yellow events arrive, the Qt application is notified by emitting the signals that were mapped in the MainWindow constructor. The mapped slot functions will then update the Qt UI as required.
#### pushButton
Responsible for communication from the Qt UI to the realtime part of the application. It uses an external port as the mechanism to allow the Qt main UI thread to inject an event when the user pushes the button in the Qt UI. Note that after each injected event the external port has to be enabled again to allow the button to be pushed another time.
The Qt UI needs access to the PushButton capsule so it can inject the event. In the sample this works by letting the PushButton state machine’s initial transition register the capsule instance with the MyThread. 
Note that the sample skips the start-up synchronization that typically is necessary for a real application. It may take some time for the realtime part of the application to start-up and during that time the Qt UI should not send messages to it. One typical solution would be to let the realtime part of the application notify the Qt UI with a signal when it is ready to start accepting events.

### Project setup with the Model RealTime and Qt Creator IDEs
Clone this repository. Open the model in folder TrafficLightsDemo in Model RealTime and generate code using the TC “app_mingw”. Note that as it’s currently set-up Model RealTime is only used for generating the code, and the build is fully done in the QT Creator IDE. In a more realistic set-up you would probably build a library from the Model RealTime model and then let the Qt application link with it.
QTTrafficLight is a Qt project that should be built with Qt Creator. Note that this project includes source files generated from the Model RealTime model. Refer to the .pro file of QTTrafficLight. Note that you may have to update the paths in the .pro file to match where you choose to place the files generated by Model RealTime.

For reference, the QTTrafficLight project was created using the following steps:
1.	Open QT Creator.
2.	Click on Create Project..
3.	Choose a template <Qt Widget Application> on New Project window. Click on <Choose>
4.	Give a project name e.g. QTtrafficLight and press on <next>
5.	Select build system <qmake> and press on <next>
6.	Uncheck <Generate form> on details page and press on <next>
7.	No change on <Translation> page and press on <next>
8.	On <kit> select <Desktop QT 6.7.0 MinGW 64-bit and press on <next>
9.	On Summary press on <finish>
10.	There are two static TargetRTS libs libObjecTime.a and libObjecTimeTypes.a present in the Model RealTime installation at this location: 

```
\eclipse\rsa_rt\C++\TargetRTS\lib\WinT.x64-MinGw-12.2.0
```

There are two TargetRTS include folders:

```
\eclipse\rsa_rt\C++\TargetRTS\include
\eclipse\rsa_rt\C++\TargetRTS\target\WinT
```

We have to add the TargetRTS interfaces from these paths while adding TargetRTS libs. We have to add both libs one by one by selecting first path for first lib and second path for second lib.

Now right click on QTtrafficLight project and click on <Add Library…>. One popup window will appear. Select external library and press <Next>. 
Click on <Browse> and select library file, Click on second <Browse> and select TargetRTS interface. 

11.	Add windows socket lib in .pro file as below.
LIBS += -lwsock32
12.	Now right click on QTtrafficLight project and select <Add Existing Directory...> then select <Browse> for source code generated by Model RealTime. Press <Start Parsing> and select only generated  .h/.cpp files.
13.	Add the path for generated .h/.cpp files in .pro file. ("ws" is the Eclipse workspace folder).

```
INCLUDEPATH += $$PWD/../ws/TrafficLightsDemo_target
```

### Project deployment and using the Model Debugger
We have to deploy QTTrafficLight.exe executable with windeployqt.exe present in Qt installation folder. When using MinGW the path for windeployqt.exe will be at a location similar to:

```
C:\QT\6.7.0\mingw_64\bin>windeployqt.exe
```

To run `QTTrafficLight.exe` from the command-line, copy the exe created by Qt IDE in separate folder. Let’s assume folder is created in C drive with name Executablefile.

Open a command prompt and issue the command below:

```
cd  C:\QT\6.7.0\mingw_64\bin

C:\QT\6.7.0\mingw_64\bin>windeployqt.exe C:\Executablefile\QTTrafficLight.exe
```

All supported files to run QTTrafficLight.exe from the command prompt will be created in Executablefile folder.

Now open a new command prompt and run the below command to run QTTrafficLight.exe so it waits for the Model Debugger to attach to it 
```
C:\Executablefile>QTTrafficLight.exe -obslisten=12345
```

You may replace the port number with something that is available on your machine.

For more information about the Model Debugger, see [the documentation](https://model-realtime.hcldoc.com/help/topic/com.ibm.xtools.rsarte.webdoc/Articles/Running%20and%20debugging/index.html?cp=23_2_13).


